2022.07.26 알고리즘의 시간 복잡도 및 빅오 계산법

시간복잡도
- 계산 복잡도 이론에서 시간 복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가리킨다
  : 단순하게 알고리즘의 수행 시간을 의미
  : 시간 복잡도가 높으면 느린 알고리즘, 시간 복잡도가 낮으면 빠른 알고리즘


빅오(Big-O) 표기법이란?
입력 n이 무한대로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것.
최고차항만 남기고 계수와 상수 제거.

1) 6n+4 / 2) 3n+2 / 3) 3n^2+6n+1

빅오 표기법에 따르면 1, 2번은 계수와 상수가 제거되면 n만 남으므로 같은 수치.
즉, 빅오로 표시하게되면 1, 2번은 O(n), 3번은 O(n^2)
매 입력마다 정확한 수식을 구하는 것은 불필요하고, 정확한 수치보다는 증가율에 초점을 맞춤.
즉, 1, 2번의 코드는 SW계에서는 크게 차이가 없다라고 판단하는 것

O(1): 단순 산술 계산(덧셈, 뺄셈, 곱셈, 나눗셈)
O(logN): 크기 N인 리스트를 반절씩 순회/탐색, 이진탐색, 분할정복
O(N): 크기 N인 리스트를 순회, 리스트 순회, 1중 for문
O(NlogN): 크기 N인 리스트를 반절씩 탐색 * 순회, 높은 성능의 정렬(Merge/Quick/Heap Sort)
O(N^2): 크기 M, N인 2중 리스트를 순회, 2중 for문
O(N^3): 3중 리스트를 순회, 3중 for문
O(2^N): 크기 N 집합의 부분 집합
O(N!): 크기 N 리스트의 순열

O(N): 1억
O(NlogN): 500만
O(N^2): 1만
O(N^3): 500
O(N!): 10

내장함수, 메서드의 시간 복잡도도 확인할 필요가 있음 !
https://wiki.python.org/moin/TimeComplexity


배열 vs 연결리스트
1) 배열: 여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조
2) 연결리스트: 데이터가 담긴 여러 노드들이 순차적으로 연견될 형태의 자료구조
    - 그래서 파이썬이 굉장히 유연하고 심플한 언어..


파이썬 리스트의 메서드 => 파이썬에서 리스트가 하나의 스택처럼 움직이기 때문에 스택을 별도로 구현할 필요가 없음.
1) .append(): 리스트 맨 끝에 새로운 원소 삽입
    - 복잡도 O(1). 사실 조회하는것은 사칙연산과 비슷한 로직으로 움직임.
2) .pop(): 특정 인덱스에 있는 원소를 삭제 및 반환
    - 복잡도 O(1).
3) .count(): 리스트에서 해당 원소의 개수를 반환
    - 복잡도 O(N)
4) .index(): 리스트에서 처음으로 원소가 등장하는 인덱스 반환
    - 복잡도 O(N). 모든 원소를 순회하기 때문에.
5) .sort(): 리스트를 오름차순으로 정렬.
    - 복잡도 O(NlogN), cost가 너무 큼.
6) .reverse(): 리스트의 원소들의 순서를 거꾸로 뒤집기
    - 복잡도 O(N). sort()에 reverse=True를 쓰는것보단 이 함수가 나을듯.

리스트의 내장함수
len(), sum(), max(), min(), sorted(), reversed()