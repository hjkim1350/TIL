1) 스택과 큐
1-1) stack : 선입 후출

stack = []
stack.append(5)
stack.append(2)
stack.append(3)
stack.pop()
stack.append(1)
stack.pop()

print(stack[::-1])

stack은 파이썬에서는 리스트와 동일하게 동작함


1-2) Queue : 선입 후출
# Queue 구현을 위해 deque 라이브러리를 사용
from collections import deque

queue = deque()

queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)
queue.popleft()
queue.append(1)
queue.append(4)
queue.popleft()

print(queue)


2) 우선순위에 따라 데이터를 꺼내는 자료구조
2-1) 우선순위 큐: 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조
- 리스트를 이용하여 구현
- 힙을 이용하여 구현

힙을 구현하는 방법?
- 완전 이진 트리 자료구조의 일종, 따라서 검색시간 O(logN)을 보장함.
- 항상 루트 노드를 제거
- 최소 Heap: 루트 노드가 가장 작은 값, 즉 작은 값이 우선적으로 제거됨
- 최대 Heap: 루트 노드가 가장 큰 값, 즉 큰 값이 우선적으로 제거됨

최소 Heap 구성 함수: Min-Heapify()
- 부모 노드로 거슬러 올라가며 부모보다 자신 값이 더 작을 경우 위치를 교체함

Heap에서 원소가 제거될 때에도 O(logN)을 보장함. 원소가 제거되었을 때 가장 마지막 노드가 루트 노드 위치에 오도록 함.
이후 루트 노드에서 하향식으로 Heapify()를 진행함.

import heapq로 모듈을 가져올 수 있음
heapq.heappush(h, value)로 삽입
heapq.heappop(h)로 제거


3) 트리
- 가계도와 같은 계층적인 구조를 표현할 때 사용

3-1) 구성요소
- 루트 노드: 더이상 부모가 없는 최상위 노드
- 단말 노드: 자식이 없는 가장 끝 노드
- 크기: 트리에 포함된 모든 노드의 개수
- 깊이: 루트 노드부터의 거리
- 높이: 깊이 중 최댓값
- 차수: 각 노드의 (자식 방향) 간선 개수
* 기본적으로 트리 크기가 N일때 전체 간선의 개수는 N-1임.

3-2) 이진 탐색 트리
- 부모 노드에 대한 자식 노드가 2개
- 데이터 크기 정렬기준: 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드

3-3) 트리의 순회
- 트리 자료구조에 포함된 노드를 특정한 방법으로 한번씩 방문하는 방법
- 전위 순회: 루트를 방문한 후 왼쪽과 오른쪽 차례로 순회
- 중위 순회: 왼쪽 자식 방문 후 루트를 방문후 오른쪽 노드 방문
- 후위 순회: 오른쪽 자식 방문 후 루트 노드 방문


4) 바이너리 인덱스 트리
- 2진법 인덱스 구조를 활용


5) 선택정렬과 삽입정렬
- 정렬이란 데이터를 특정한 기준에 따라 순서대로 나열


6) 퀵 정렬과 계수 정렬
6-1) 퀵정렬
- 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 서로 바꾸는 방법
- 병합정렬과 더불어 대부분의 프로그래밍언어의 정렬 라이브러리의 근간이 되는 알고리즘임.
- 퀵 정렬은 첫번째 데이터를 기준 데이터로 설정함.
- 이상적인 경우 분할이 절반씩 일어난다면 전체 연산횟수로 O(NlogN)을 기대할 수 있음.

6-2) 계수정렬
- 특정한 조건이 부합할 때만 사용 가능하지만 매우 빠르게 동작하는 정렬 알고리즘
- O(N+K)를 보장함
- 하지만 때에 따라서 심각한 비효율성을 초래할 수 있음
- 동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용할 수 있음


7) 정렬알고리즘 비교하기
- 선택정렬: O(N^2) 아이디어가 매우 간단
- 삽입정렬: O(N^2) 선택정렬에 비해 조금 더 빠름, 특히 데이터가 거의 정렬되어 있을때 가장 빠름
- 퀵 정렬: O(NlogN) 대부분 가장 적합하며 충분히 빠름
- 계수 정렬: O(N+K) 데이터 크기가 한정적인 경우에만 사용 가능하지만 매우 빠르게 동작함


8) 그래프 탐색의 기본, DFS와 BFS
8-1) DFS (Depth-First Search) 깊이우선탐색
- 깊이우선 탐색, 깊은 부분을 우선적으로 탐색하는 알고리즘
  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 함
  2. 스택의 최상단 노드에 방문하지 않고 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리함.
      방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄.
  3. 더이상 2번의 과정을 수행할 수 없을 때까지 반복.
* python 코드
def dfs(graph, v, visited)
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end= ' ')
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]
        if not visited[i]:
            dfs(graph, i, visited)

8-2) BFS (Breath-Firsth Search) 너비우선탐색
- 그래프에서 가까운 노드부터 우선적으로 탐색
- 큐 자료구조를 이용함
  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 함
  2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않는 노드를 모두 큐에 삽입하고 방문 처리
  3. 더이상 2번의 과정을 수행할 수 없을 때까지 반복.
- 특정 조건에서 최단 경로를 구하는데 자주 쓰이는 탐색 기법 중 하나.

* python 코드
from collections import deque

def bfs(graph, start, visited):
    # 큐 구현을 위해 deque 라이브러리 사용
    queue = deque([start])
    # 현재 노드를 방문 처리
    visited[start] = True
    # 큐가 빌 때까지 반복
    while queue:
        # 큐에서 하나의 원소를 뽑아 출력하기
        v = queue.popleft()
        print(v, end=' ')
        # 아직 방문하지 않은 인접한 원소들을 큐에 삽입
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True